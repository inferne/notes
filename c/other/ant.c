/* *
 * 蚁群算法
 *     尽管蚂蚁个体比较简单,但整个蚂蚁群体却表现为高度机构化的社会组织,
 * 在许多情况下能完成远远超过蚂蚁个体能力的复杂任务[1 0]。这种能力来源于蚂
 * 蚁群体中的个体协作行为,其群体行为主要包括寻找食物、任务分配和构造墓地等三种。
 *     自然界中,蚂蚁的食物源总是随机散布于蚁巢周围。我们只要仔细观察就可
 * 以发现,经过一段时间后,蚂蚁总能找到一条从蚁巢到食物源的最短路径。
 *     单只蚂蚁的能力和智力非常简单,但它们通过相互协调、分工、合作完成不
 * 论工蚁还是蚁后都不可能有足够能力来指挥完成的筑巢、觅食、迁徙、清扫蚁穴
 * 等复杂行为,比如蚂蚁在觅食过程中能够通过相互协作找到食物源和巢穴之间的
 * 最短路径。在现实生活中,我们总可以观察到大量蚂蚁在巢穴与食物源之
 * 间形成近乎直线的路径,而不是曲线或者圆等其他形状。蚂
 * 蚁群体不仅能完成复杂的任务,而且还能适应环境的变化,如在蚁群运动路线上
 * 突然出现障碍物时,一开始各只蚂蚁分布是均匀的,不管路径长短,蚂蚁总是先
 * 按同等概率选择各条路径。蚂蚁在运动过程中,能够在其经
 * 过的路径上留下信息素,而且能感知这种物质的存在及其强度,并以此指导自己
 * 运动的方向,蚂蚁倾向于信息素浓度高的方向移动。相等时间内较短路径上的信
 * 息量就遗留得比较多,则选择较短路径的蚂蚁也随之增多。
 * 不难看出,由于大量蚂蚁组成的蚁群集体行为表现出了一种信息正反馈现象,即
 * 某一路径上走过的蚂蚁越多,则后来者选择该路径的概率就越大,蚂蚁个体之间
 * 就是通过这种信息交流机制来搜索食物,并最终沿着最短路径行进。
 *     Goss S 等曾于 1989 年做了著名的 “双桥”实验。
 * 该实验表明,蚁群最终会选择一条从巢穴到食物源(觅食区)的最短路径。
 *     Goss S 等通过进一步研究,给出了 “双桥”实验的数学模型。首先,假
 * 设在非对称桥上的信息量与过去一个时间段内经过该桥的蚂蚁数目成正比;其
 * 次,假设某一时刻蚂蚁按照桥上残留信息量的多少来选择其中某座桥,经过该桥
 * 的蚂蚁数目越多,则该桥上的残留信息量就越大。该实例中,假设短桥为 A,长
 * 桥为 B, Am 和 Bm 分别表示经过桥 A 和桥 B 的蚂蚁数目 (Am + Bm = m),则当
 * 所有 m 只蚂蚁都经过两座桥之后,第 m + 1 只蚂蚁选择桥 A 的概率为
 *     PA (m)= (A m + k)^h / ( (A m + k)^h + (Bm + k)^h )
 * 而选择桥 B 的概率为
 *     PB (m)= 1 - PA (m)
 * 式中,参数 h 和 k 用以匹配真实实验数据。第 m + 1 只蚂蚁首先按照公式
 * 计算选择概率 PA (m),然后生成一个在区间 [0,1]上均匀分布的随机
 * 数 φ,若 φ≤ PA (m),则选择桥 A;否则选择桥 B。
 */

#include <stdio.h>

/*
|                              
|                              
|                              
|                              
|           .  .                
|        .  .                   
|     .        .               
|     .  .  .                   
|  .                         
|__ __ __ ________________________
*/

//a,b,c,d,e,f,g,h,i,j)
int graph_matrix[
        [0,3,0,0,4,0,0,0,0,0]
        [0,0,2,2,0,0,0,0,0,0]
        [0,0,0,2,0,0,5,0,0,0]
        [0,0,0,0,0,3,0,4,0,0]
        [0,0,0,0,0,0,3,0,0,0]
        [0,0,0,0,0,0,0,3,0,4]
        [0,0,0,0,0,0,0,2,3,0]
        [0,0,0,0,0,0,0,0,2,3]
        [0,0,0,0,0,0,0,0,0,2]
        [0,0,0,0,0,0,0,0,0,0]
	];

//信息素矩阵
int pheromone_matrix[10][10] = {0};

//算法迭代次数
int iteratorNum = 10;

//蚂蚁数量
int ant = 100;

//蚂蚁的路径
int path_matrix[100][10];

void search() {
	int k = 1;
	int h = 1;
	for (n = 0; n < ant; n++) {
		/* 
		按信息素计算概率  
		公式：Pa = (a + k)^h/((a + k)^h + (b + k)^h + ...)
		取k = 1, h = 1
		*/
		for (i = 0; i < 10; i++) {
			m = 0;
			//累加可选路径的信息素
			for (j = 0; j < 10; j++) {
				if (graph_matrix[i][j] > 0) {
					pheromoneSum += pheromone_matrix[i][j] + k;
				}
			}
			//
			f = 0;//表示蚂蚁是否已经选择了一条路径
			P = 0;//计算的概率
			do {
				for (j = i; j < 10; j++) {
					if (graph_matrix[i][j] > 0) {
						P = (pheromone_matrix[i][j] + k) / pheromoneSum;
						if (P > random(0,99)/100) {
							path_matrix[n][i] = j;
							f = 1;
							break;
						}
					}
				}
			} while ( f == 1 );
		}
	}
}

//更新信息素矩阵
void update_pheromone() {
	for (n = 0; n < ant; n++) {
		for (i = 0; i < 10; i++) {
			for (j = i; j < 10; j++) {
				if (path_matrix[n][i] == j) {
					pheromone_matrix[i][j] + 1/graph_matrix[i][j];//路径越大，衰减越快
				}
			}
		}
	}
}

//输出信息素浓度最大的路径
void printf_max_pheromone_path() {
	for (i = 0; i < 10; i++) {
		max = 0;
		node = 0;
		for (j = i; j < 10; j++) {
			if (pheromone_matrix[i][j] > max) {
				 max = pheromone_matrix[i][j];
				 node = j;
			}
		}
		printf("node=%d max=%d\n", node, max);
	}
}

int main () {
	//多次迭代
	for (i = 0; i < iteratorNum; i++) {
		//搜索蚂蚁爬行路径矩阵
		search();
		//更新信息素矩阵
		update_pheromone();
	}
	//输出信息素浓度最大的路径
	printf_max_pheromone_path();
}